# 动态规划

## 动态规划的步骤

1. 所有的动态规划都来自于暴力递归
2. 但是动态规划会将解记录下来





## 最小路径和

给一个二维数组,数组的每个数字都是正数,要求从左上角到右下角,每一步只能向右或者向下.沿途经过的数字要累加起来,返回最小的路径和

### 普通解法

```java
public int minPath(int[][] matrix){
    return process( matrix,0,0);
}

public int process(int [][] matrix,int i,int j){
    if(i==matrix.length-1&&j==matrix[0].length-1)
        return matrix[i][j];
    
    //这两if顺序不大
    if(i==matrix.length-1)
        return matrix[i][j]+process(matrix,i,j+1);
    if(j==matrix[0].length-1)
        return matrix[i][j]+process(matrix,i+1,j);
    return matrix[i][j]+Math.min(process(matrix,i,j+1),process(matrix,i+1,j))
}

```

### 普通版本升级

```java
public int minPath(int[][] matrix){
    return process(matrix,matrix.length-1,matrix[0].length-1);
}

public int process(int[][]matrix,int i,int j){
    int res=matrix[i][j];
    if(i==0&&j==0)
        return res;
    if(i==0&&j!=0)
        return res+process(matrix,i,j-1);
    if(i!=0&&j==0)
        return res+process(matrix,i-1,j);
    return res+Math.min(process(matrix,i,j-1),process(matrix,i-1,j));
}
```



### 缓存解法

```java
HashMap<String,Integer> cache=new HashMap<>();
public int process(int [][] matrix,int i,int j){
    if(i==matrix.length-1&&j==matrix[0].length-1)
        return matrix[i][j];
    
    //这两if顺序不大
    else if(i==matrix.length-1){
        int next=0;
        String nextKey=String.valueof(i)+String.valueof(j+1);
        if(cache.containsKey(nextKey))
            next=cache.get(nextKey);
        else
            next=process(matrix,i,j+1);
        result= matrix[i][j]+next;
    }
        
    else if(j==matrix[0].length-1){
         int down=0;
         String downKey=String.valueof(i+i)+String.valueof(j);
         if(cache.containsKey(downKey))
            next=cache.get(downKey);
         else
            next=process(matrix,i+1,j);
        result= matrix[i][j]+next;
    }
    else{
        int next=0;
        int down=0;
        String nextKey=String.valueof(i)+String.valueof(j+1);
        if(cache.containsKey(nextKey))
            next=cache.get(nextKey);
        else
            next=process(matrix,i,j+1);
         
        String downKey=String.valueof(i+i)+String.valueof(j);
         if(cache.containsKey(downKey))
            next=cache.get(downKey);
         else
            next=process(matrix,i+1,j);
        result= matrix[i][j]+Math.min(next,down);
    }

    String key=String.valueof(i)+"-"+String.valueof(j);
    cache.put(key,result);
    return result;
}
```



### 动态规划

```java
public int minPath(int[][] matrix){
    if(matrix==null||matrix.length==0||matrix[0]==null||matrix[0].length==0)
        return 0;
    int row=matrix.length;
    int col=matrix[0].length;
    int[][] dp=new int [row][col];
    dp[row-1][col-1]=matrix[row-1][col-1];
    
    //矩阵最右边界
    for(int i=row-2;i>=0;i--)
        dp[i][0]=dp[i+1][col-1]+matrix[i][col-1];
    //矩阵最下边界
    for(int j=col-2;j>=0;j--)
        dp[0][j]=dp[row-1][j+1]+matrix[row-1][j];
    
    
    for(int i=row-2;i>=0;i--){
        for(int j=col-2;j>=0;j--)
            dp[i][j]=Math.min(dp[i+1][j],dp[i][j+1])+matrix[i][j];
    }
    return dp[0][0];
}
```



## 求解数组子集是否又符合元素

给一个数组arr 和一个正数aim  如果可以选择arr的任意几个数组 看看是否他们的额和为aim 返回ture或者false

### 递归解决

```java
public boolean hasZiJI(int[] arr,int aim){
    return process(arr,0,0,aim);
}
// 数组  当前索引  当前总数 aim
public void boolean process(int[] arr,int i,int sum,int aim){
    //当遍历完所有的可能性的时候
    if(i==arr.length){
        return sum==aim;
    }
    return
        //加上该数和不加上该数
        process(arr,i+1,sum,aim)||process(arr,i+1,sum+arr[i],aim);
}
```

